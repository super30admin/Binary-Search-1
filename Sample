// Time Complexity :
// Space Complexity :
// Did this code successfully run on Leetcode :
// Any problem you faced while coding this :


// Your code here along with comments explaining your approach


1) Search in a Rotated Sorted Array

Time Complexity: O(logn) -> Since we are using binary search which tends to ignore half of the unnecessary search of elements 

Space Complexity: O(1) -> Since we are not using any auxillary space.

Leetcode Submission: Done

Algorithm: 

In Rotated Sorted arrays, one side is always sorted.

1) Edge case : if array is null or has length 0
2) Base case: Low & high should not intercross each other.
3) if low <= nums[mid] ==> left array is sorted
			a) check if target exists within nums[low] && nums[mid]
								If yes, target is present in left sub array
								high = mid-1
			b) else its present in right subarray	
								low = mid+1
4) else right array is sorted 
			a) check if target is present within mid and high
							if yes, target is present in right subarray
							low = mid+1
				b) else in left sub array				
								high = mid-1




---------------------------------------------------------------------------------------------


2) Search in Infinite sorted array.


Time Complexity: O(logn) -> Ultimately we are using binary search till we find the target

Space Complexity: O(1) -> Since we are not using any extra space here for calculating the result

Leetcode Submission: Done

Algorithm: 

1. In an infinte sorted array, we dont have any specific value for high so,
2. low = 0 & high =1
3. we will keep increasing our low and high until array[high] <= target since its a sorted array
4. Apply binary search on that
