#Time Complexity : O(log n) beacuse of binary search
#Space Complexity : I am using the iterative version of binary serach, so It's O(1)
#Did this code successfully run on Leetcode : Yes
#Any problem you faced while coding this : No

#Your code here along with comments explaining your approach

class Solution(object):
    def search(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        if len(nums)==0:
            return -1
        elif len(nums)==1:
            if nums[0]==target:
                return 0
            else:
                return -1
        else:
            if nums[0]<=nums[len(nums)-1]:
                start=0
                end=len(nums)-1
                flag=0
                while start<=end:
                    mid=(start+end)//2
                    if nums[mid]==target:
                        flag=1
                        break

                    elif nums[mid]>target:
                        end=mid-1
                    elif nums[mid]<target:
                        start=mid+1
                if flag==1:
                    return mid
                else:
                    return -1
                
            else:
                start=0 
                end=len(nums)-1

                while start<=end:
                    mid=(start+end)//2

                    if nums[mid]>nums[mid+1]:
                        pivot=mid+1
                        break

                    elif nums[start]<=nums[mid]:
                        start=mid+1
                    elif nums[start]>nums[mid]:
                        end=mid-1

                #print(pivot)
                start=0
                end=len(nums)-1


                if nums[pivot]<=target<=nums[end]:
                    start=pivot
                    end=len(nums)-1
                    flag=0
                    while start<=end:
                        mid=(start+end)//2
                        if nums[mid]==target:
                            flag=1
                            break

                        elif nums[mid]>target:
                            end=mid-1
                        elif nums[mid]<target:
                            start=mid+1
                    if flag==1:
                        return mid
                    else:
                        return -1

                else:
                    start=0
                    end=pivot-1
                    flag=0
                    while start<=end:
                        mid=(start+end)//2
                        if nums[mid]==target:
                            flag=1
                            break

                        elif nums[mid]>target:
                            end=mid-1
                        elif nums[mid]<target:
                            start=mid+1
                    if flag==1:    
                        return mid
                    else:
                        return -1
