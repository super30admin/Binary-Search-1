# -*- coding: utf-8 -*-
"""SearchinRotatedArray.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QwkKfIkqHc4ZM9lo-LtSLlglmILMsMsY
"""

class Solution:
    def search(self, nums: List[int], target: int) -> int:
        
        low = 0
        high = len(nums) - 1
        
        while (low <= high):
            
            mid = (low + high)//2
            
            if(nums[mid] == target):
                return mid
            
            elif(nums[mid] >= nums[low]):
                if(target >=nums[low] and target < nums[mid]):
                    high =mid -1
                else:
                    low = mid + 1
                    
            else:
                if(nums[high] >= target and nums[mid] < target):
                    low = mid + 1
                else:
                    high = mid -1
                    
                        
        return - 1
                    
        
        
#Time Complexity : O(log(n))
#Space Complexity : O(1)
#Did this code successfully run on Leetcode : yes
#Any problem you faced while coding this : No


#Your code here along with comments explaining your approach
#Dividng the search space in half, by comparing middle elements with the low element to find which side is sorted and doing the binary search ono the sorted side to find the element