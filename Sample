1.
#Time Complexity : O(log(M+N))
#Space Complexity : O(1)
#Did this code successfully run on Leetcode : Yes
#Any problem you faced while coding this : No


# started from first row last column. increased row if current element is less 
# than target and decresed column if it's greater than.


class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        row = 0
        col = len(matrix[0]) - 1
        
        while(row<len(matrix) and col>=0):
            if(matrix[row][col])==target:
                return True
            elif(matrix[row][col]<target):
                row+=1
            else:
                col-=1
        return False


2.
#Time Complexity : O(log(n))
#Space Complexity : O(1)
#Did this code successfully run on Leetcode : Yes
#Any problem you faced while coding this : No


# binary serch in rotated array. if target is greater than mid element or less than first, then find
# element in right part, and vice versa

class Solution:
    def search(self, nums: List[int], target: int) -> int:
        n = len(nums)
        low = 0 
        high = n-1
        while(low<=high):
            mid = ( high + low ) // 2
            if(nums[mid]==target):
                return mid
            if(nums[low]<=nums[mid]):
                #left sorted
                if target > nums[mid] or target < nums[low]:
                    low = mid + 1
                else:
                    high = mid - 1   
            else:
                #right sorted
                if target < nums[mid] or target > nums[high]:
                    high = mid - 1
                else:
                    low = mid + 1
        return -1


3.
#Time Complexity : O(log(p)) p is the index of target  
#Space Complexity : O(1)
#Did this code successfully run on Leetcode : Yes
#Any problem you faced while coding this : No


# """
# This is ArrayReader's API interface.
# You should not implement it, or speculate about its implementation
# """
#class ArrayReader:
#    def get(self, index: int) -> int:

class Solution:
    def search(self, reader, target):
        if reader.get(0) == target:
            return 0
        
        # search boundaries
        low, high = 0, 1
        while reader.get(high) < target:
            low = high
            high *= 2
        
        # binary search
        while low <= high:
            mid = low + ((high - low) >> 1)
            num = reader.get(mid)
            
            if num == target:
                return mid
            if num > target:
                high = mid - 1
            else:
                low = mid + 1
        return -1

